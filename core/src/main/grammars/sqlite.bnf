{
  parserUtilClass="com.alecstrong.sqlite.psi.core.ModuleParserUtil"
  parserClass = "com.alecstrong.sqlite.psi.core.parser.SqliteParser"
  elementTypeClass = "com.alecstrong.sqlite.psi.core.SqliteElementType"

  implements="com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  extends="com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElementImpl"

  psiClassPrefix = "Sqlite"
  psiImplClassSuffix = "Impl"
  psiPackage = "com.alecstrong.sqlite.psi.core.psi"
  psiImplPackage = "com.alecstrong.sqlite.psi.core.psi.impl"

  tokens=[
    SEMI=';'
    EQ='='
    LP='('
    RP=')'
    DOT='.'
    COMMA=','
    PLUS='+'
    MINUS='-'
    BITWISE_NOT='~'
    SHIFT_RIGHT='>>'
    SHIFT_LEFT='<<'
    LT='<'
    GT='>'
    LTE='<='
    GTE='>='
    EQ2='=='
    NEQ='!='
    NEQ2='<>'
    MULTIPLY='*'
    DIVIDE='/'
    MOD='%'
    BITWISE_AND='&'
    BITWISE_OR='|'
    CONCAT='||'

    space='regexp:\s+'
    comment='regexp:--.*'
    javadoc='regexp:/\*\*(.|\n)*\*/'
    digit='regexp:\d+(\.\d*)?'
    id='regexp:([a-zA-Z0-9_\`\[\]])*'
    string="regexp:('([^'])*'|\"([^\"])*\")"
  ]
  extends(".*expr")=expr
}

sql_stmt_list ::= statement * {
  mixin="com.alecstrong.sqlite.psi.core.psi.mixins.SqlStmtListMixin"
}
statement ::= sql_stmt ';' {
  pin=1
}
sql_stmt ::= [ EXPLAIN [ QUERY PLAN ] ] ( alter_table_stmt | analyze_stmt | attach_stmt | begin_stmt | commit_stmt | create_index_stmt | create_table_stmt | create_trigger_stmt | create_view_stmt |
                                          create_virtual_table_stmt | delete_stmt_limited | detach_stmt | drop_index_stmt | drop_table_stmt | drop_trigger_stmt | drop_view_stmt | insert_stmt |
                                          pragma_stmt | reindex_stmt | release_stmt | rollback_stmt | savepoint_stmt | compound_select_stmt | update_stmt_limited | vacuum_stmt
                                        ) {
  recoverWhile=sql_stmt_recovery
  pin = 2
}
private sql_stmt_recovery ::= !( ';' | ALTER | ANALYZE | ATTACH | BEGIN | COMMIT | END | ROLLBACK | SAVEPOINT | RELEASE | CREATE | DROP | INSERT | WITH | UPDATE | DELETE | SELECT | PRAGMA | REINDEX )
alter_table_stmt ::= ALTER TABLE [ database_name '.' ] table_name ( RENAME TO new_table_name | ADD [ COLUMN ] column_def ) {
  pin = 1
}
analyze_stmt ::= ANALYZE [ database_name | table_or_index_name | database_name '.' table_or_index_name ] {
  pin = 1
}
attach_stmt ::= ATTACH [ DATABASE ] expr AS database_name {
  pin = 1
}
begin_stmt ::= BEGIN [ DEFERRED | IMMEDIATE | EXCLUSIVE ] [ TRANSACTION ] {
  pin = 1;
}
commit_stmt ::= ( COMMIT | END ) [ TRANSACTION ] {
  pin = 1
}
rollback_stmt ::= ROLLBACK [ TRANSACTION ] [ TO [ SAVEPOINT ] savepoint_name ] {
  pin = 1
}
savepoint_stmt ::= SAVEPOINT savepoint_name {
  pin = 1
}
release_stmt ::= RELEASE [ SAVEPOINT ] savepoint_name {
  pin = 1
}
create_index_stmt ::= CREATE [ UNIQUE ] INDEX [ IF NOT EXISTS ] [ database_name '.' ] index_name ON table_name '(' indexed_column ( ',' indexed_column ) * ')' [ WHERE expr ] {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.CreateIndexMixin"
  pin = 6
}
indexed_column ::= column_name [ COLLATE collation_name ] [ ASC | DESC ]
create_table_stmt ::= CREATE [ TEMP | TEMPORARY ] TABLE [ IF NOT EXISTS ] [ database_name '.' ] table_name ( '(' column_def ( ',' column_def ) * ( ',' table_constraint ) * ')' [ WITHOUT ROWID ] | AS compound_select_stmt ) {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.CreateTableMixin"
  implements = "com.alecstrong.sqlite.psi.core.psi.TableElement"
  pin = 6
}
column_def ::= column_name type_name ( column_constraint ) *
type_name ::= identifier [ '(' signed_number ')' | '(' signed_number ',' signed_number ')' ]
column_constraint ::= [ CONSTRAINT identifier ] ( PRIMARY KEY [ ASC | DESC ] conflict_clause [ AUTOINCREMENT ] | NOT NULL conflict_clause | UNIQUE conflict_clause | CHECK '(' expr ')' | DEFAULT ( signed_number | literal_value | '(' expr ')' ) | COLLATE collation_name | foreign_key_clause )
signed_number ::= [ '+' | '-' ] numeric_literal
table_constraint ::= [ CONSTRAINT identifier ] ( ( PRIMARY KEY | UNIQUE ) '(' indexed_column ( ',' indexed_column ) * ')' conflict_clause | CHECK '(' expr ')' | FOREIGN KEY '(' column_name ( ',' column_name ) * ')' foreign_key_clause )
foreign_key_clause ::= REFERENCES foreign_table [ '(' column_name ( ',' column_name ) * ')' ] [ ( ON ( DELETE | UPDATE ) ( SET NULL | SET DEFAULT | CASCADE | RESTRICT | NO ACTION ) | MATCH identifier ) * ] [ [ NOT ] DEFERRABLE [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ] ] {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.ForeignKeyClauseMixin"
}
conflict_clause ::= [ ON CONFLICT ( ROLLBACK | ABORT | FAIL | IGNORE | REPLACE ) ]
create_trigger_stmt ::= CREATE [ TEMP | TEMPORARY ] TRIGGER [ IF NOT EXISTS ] [ database_name '.' ] trigger_name [ BEFORE | AFTER | INSTEAD OF ] ( DELETE | INSERT | UPDATE [ OF column_name ( ',' column_name ) * ] ) ON table_name [ FOR EACH ROW ] [ WHEN expr ] BEGIN ( (update_stmt | insert_stmt | delete_stmt | compound_select_stmt ) ';' ) + END {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.CreateTriggerMixin"
  pin = 6
}
create_view_stmt ::= CREATE [ TEMP | TEMPORARY ] VIEW [ IF NOT EXISTS ] [ database_name '.' ] view_name AS compound_select_stmt {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.CreateViewMixin"
  implements = "com.alecstrong.sqlite.psi.core.psi.TableElement"
  pin = 6
}
create_virtual_table_stmt ::= CREATE VIRTUAL TABLE [ IF NOT EXISTS ] [ database_name '.' ] table_name USING module_name [ '(' <<custom_module_argument column_def>> ( ',' <<custom_module_argument column_def>> ) * ')' ] {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.CreateVirtualTableMixin"
  implements = "com.alecstrong.sqlite.psi.core.psi.TableElement"
  pin = 6
}
module_argument ::= [ column_def ]
with_clause ::= WITH [ RECURSIVE ] cte_table_name AS '(' compound_select_stmt ')' ( ',' cte_table_name AS '(' compound_select_stmt ')' ) * {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.WithClauseMixin"
  pin = 1
}
cte_table_name ::= table_name [ '(' column_alias ( ',' column_alias ) * ')' ]
delete_stmt ::= [ with_clause ] DELETE FROM qualified_table_name [ WHERE expr ] {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.MutatorMixin"
  pin = 4
}
delete_stmt_limited ::= [ with_clause ] DELETE FROM qualified_table_name [ WHERE expr ] [ [ ORDER BY ordering_term ( ',' ordering_term ) * ] LIMIT expr [ ( OFFSET | ',' ) expr ] ] {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.MutatorMixin"
  pin = 4
}
detach_stmt ::= DETACH [ DATABASE ] database_name {
  pin = 1
}
drop_index_stmt ::= DROP INDEX [ IF EXISTS ] [ database_name '.' ] index_name {
  pin = 2
}
drop_table_stmt ::= DROP TABLE [ IF EXISTS ] [ database_name '.' ] table_name {
  pin = 2
}
drop_trigger_stmt ::= DROP TRIGGER [ IF EXISTS ] [ database_name '.' ] trigger_name {
  pin = 2
}
drop_view_stmt ::= DROP VIEW [ IF EXISTS ] [ database_name '.' ] view_name {
  pin = 2
}
expr ::= ( raise_expr
         | case_expr
         | exists_expr
         | paren_expr
         | binary_or_expr
         | binary_and_expr
         | between_expr
         | binary_like_expr
         | is_expr
         | null_expr
         | collate_expr
         | cast_expr
         | function_expr
         | in_expr
         | binary_equality_expr
         | binary_boolean_expr
         | binary_bitwise_expr
         | binary_add_expr
         | binary_mult_expr
         | binary_pipe_expr
         | unary_expr
         | literal_expr
         | column_expr
         | bind_expr )

literal_expr ::= literal_value
bind_expr ::= bind_parameter
column_expr ::= [ database_name '.' table_name '.' | table_name '.' ] column_name
unary_expr ::= ('+' | '-' | '~' ) expr
binary_pipe_expr ::= expr '||' expr {
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteBinaryExpr"
}
binary_mult_expr ::= expr ( '*' | '/' | '%' ) expr {
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteBinaryExpr"
}
binary_add_expr ::= expr ( '+' | '-' ) expr {
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteBinaryExpr"
}
binary_bitwise_expr ::= expr ( '<<' |  '>>' | '&' | '|' ) expr {
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteBinaryExpr"
}
binary_boolean_expr ::= expr (  '<' | '<=' | '>' | '>=' ) expr {
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteBinaryExpr"
}
binary_equality_expr ::= expr ( '=' | '==' | '!=' | '<>' ) expr {
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteBinaryExpr"
}
binary_and_expr ::= expr AND expr {
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteBinaryExpr"
}
binary_or_expr ::= expr OR expr {
  implements = "com.alecstrong.sqlite.psi.core.psi.SqliteBinaryExpr"
}
function_expr ::= function_name '(' [ [ DISTINCT ] expr ( ',' expr ) * | '*' ] ')'
paren_expr ::= '(' expr ')' {
  pin = 1
}
cast_expr ::= CAST '(' expr AS type_name ')'
collate_expr ::= expr COLLATE collation_name
binary_like_operator ::= ( LIKE | GLOB | REGEXP | MATCH )
binary_like_expr ::= expr [ NOT ] ( binary_like_operator ) expr [ ESCAPE expr ] {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.BinaryLikeExprMixin"
}
null_expr ::= expr ( ISNULL | NOTNULL | NOT NULL )
is_expr ::= expr IS [ NOT ] expr
between_expr ::= expr [ NOT ] BETWEEN expr AND expr
in_expr ::= expr [ NOT ] IN ( '(' [ compound_select_stmt | expr ( ',' expr ) * ] ')' | [ database_name '.' ] table_name | bind_expr ) {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.InExprMixin"
  pin = 3
}
exists_expr ::= [ [ NOT ] EXISTS ] '(' compound_select_stmt ')'
case_expr ::= CASE [ expr ] WHEN expr THEN expr ( WHEN expr THEN expr )* [ ELSE expr ] END {
  pin = 1
}
raise_expr ::= raise_function
raise_function ::= RAISE '(' ( IGNORE | ( ROLLBACK | ABORT | FAIL ) ',' error_message ) ')'
literal_value ::= ( numeric_literal
                  | string_literal
                  | blob_literal
                  | NULL
                  | CURRENT_TIME
                  | CURRENT_DATE
                  | CURRENT_TIMESTAMP ) {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.LiteralValueMixin"
}
numeric_literal ::= ( digit [ '.' ( digit ) * ] | '.' digit ) [ E [ '+' | '-' ] digit ]
insert_stmt ::= [ with_clause ] ( INSERT OR REPLACE | REPLACE | INSERT OR ROLLBACK | INSERT OR ABORT | INSERT OR FAIL | INSERT OR IGNORE | INSERT ) INTO [ database_name '.' ] table_name [ '(' column_name ( ',' column_name ) * ')' ] ( VALUES values_expression ( ',' values_expression ) * | compound_select_stmt | DEFAULT VALUES ) {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.InsertStmtMixin"
  pin = 5
}
pragma_stmt ::= PRAGMA [ database_name '.' ] pragma_name [ '=' pragma_value | '(' pragma_value ')' ] {
  pin = 1
}
pragma_value ::= ( signed_number
                 | identifier
                 | string_literal )
reindex_stmt ::= REINDEX [ collation_name | [ database_name '.' ] ( table_name | index_name ) ] {
  pin = 1
}
compound_select_stmt ::= [ with_clause ] select_stmt  ( compound_operator select_stmt ) * [ ORDER BY ordering_term ( ',' ordering_term ) * ] [ LIMIT limiting_term [ ( OFFSET | ',' ) limiting_term ] ] {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.CompoundSelectStmtMixin"
  implements = [
    "com.alecstrong.sqlite.psi.core.psi.QueryElement";
    "com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  ]
}
limiting_term ::= expr
select_stmt ::= SELECT [ DISTINCT | ALL ] result_column ( ',' result_column ) * [ FROM join_clause ] [ WHERE expr ] [ GROUP BY expr ( ',' expr ) * [ HAVING expr ] ] | VALUES values_expression ( ',' values_expression ) * {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.SelectStmtMixin"
  implements = [
    "com.alecstrong.sqlite.psi.core.psi.QueryElement";
    "com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  ]
  pin = 1
}
values_expression ::= '(' expr ( ',' expr ) * ')'
join_clause ::= table_or_subquery ( join_operator table_or_subquery join_constraint ) * {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.JoinClauseMixin"
  implements = [
    "com.alecstrong.sqlite.psi.core.psi.QueryElement";
    "com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  ]
}
table_or_subquery ::= ( [ database_name '.' ] table_name [ [ AS ] table_alias ] [ INDEXED BY index_name | NOT INDEXED ]
                      | '(' ( table_or_subquery ( ',' table_or_subquery ) * | join_clause ) ')'
                      | '(' compound_select_stmt ')' [ [ AS ] table_alias ] ) {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.TableOrSubqueryMixin"
  implements = [
    "com.alecstrong.sqlite.psi.core.psi.QueryElement";
    "com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  ]
}
result_column ::= ( '*'
                  | table_name '.' '*'
                  | expr [ [ AS ] column_alias ] ) {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.ResultColumnMixin"
  implements = [
    "com.alecstrong.sqlite.psi.core.psi.QueryElement";
    "com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  ]
}
join_operator ::= ( ','
                  | [ NATURAL ] [ LEFT [ OUTER ] | INNER | CROSS ] JOIN )
join_constraint ::= [ ON expr | USING '(' column_name ( ',' column_name ) * ')' ]
ordering_term ::= expr [ COLLATE collation_name ] [ ASC | DESC ]
compound_operator ::= ( UNION ALL
                      | UNION
                      | INTERSECT
                      | EXCEPT )
update_stmt ::= [ with_clause ] UPDATE [ OR ROLLBACK | OR ABORT | OR REPLACE | OR FAIL | OR IGNORE ] qualified_table_name SET column_name '=' setter_expression update_stmt_subsequent_setter * [ WHERE expr ] {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.MutatorMixin"
  pin = 4
}
update_stmt_limited ::= [ with_clause ] UPDATE [ OR ROLLBACK | OR ABORT | OR REPLACE | OR FAIL | OR IGNORE ] qualified_table_name SET column_name '=' setter_expression update_stmt_subsequent_setter * [ WHERE expr ] [ [ ORDER BY ordering_term ( ',' ordering_term ) * ] LIMIT expr [ ( OFFSET | ',' ) expr ] ] {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.MutatorMixin"
  pin = 4
}
update_stmt_subsequent_setter ::= ',' column_name '=' setter_expression {
  pin = 1
}
setter_expression ::= expr
qualified_table_name ::= [ database_name '.' ] table_name [ INDEXED BY index_name | NOT INDEXED ]
vacuum_stmt ::= VACUUM
table_name ::= id {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.TableNameMixin"
  implements = [
    "com.alecstrong.sqlite.psi.core.psi.NamedElement";
    "com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  ]
}
database_name ::= id
index_name ::= id
column_name ::= id | string {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.ColumnNameMixin"
  implements = [
    "com.alecstrong.sqlite.psi.core.psi.NamedElement";
    "com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  ]
}
column_alias ::= id {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.ColumnAliasMixin"
  implements = [
    "com.alecstrong.sqlite.psi.core.psi.AliasElement";
    "com.alecstrong.sqlite.psi.core.psi.NamedElement";
    "com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  ]
}
table_alias ::= id {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.TableAliasMixin"
  implements = [
    "com.alecstrong.sqlite.psi.core.psi.NamedElement";
    "com.alecstrong.sqlite.psi.core.psi.AliasElement";
    "com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  ]
}
foreign_table ::= id {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.TableNameMixin"
  implements = [
    "com.alecstrong.sqlite.psi.core.psi.NamedElement";
    "com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  ]
}
identifier ::= id
pragma_name ::= id
function_name ::= id
string_literal ::= string
table_or_index_name ::= id
new_table_name ::= id
savepoint_name ::= id
trigger_name ::= id
blob_literal ::= '0x' digit
collation_name ::= id
error_message ::= string
view_name ::= id {
  mixin = "com.alecstrong.sqlite.psi.core.psi.mixins.TableNameMixin"
  implements = [
    "com.alecstrong.sqlite.psi.core.psi.NamedElement";
    "com.alecstrong.sqlite.psi.core.psi.SqliteCompositeElement"
  ]
}
module_name ::= id
bind_parameter ::= ( '?' [digit] | ':' identifier )
